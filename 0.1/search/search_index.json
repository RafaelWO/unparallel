{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unparallel","text":"<p>Create Python async web requests in no time with unparallel!</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install unparallel\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>A simple example of doing a number of GET requests to an HTTP web service:</p> <pre><code>import asyncio\nfrom unparallel import up\n\nasync def main():\n    url = \"https://httpbin.org\"\n    paths = [f\"/get?i={i}\" for i in range(5)]\n    results = await up(url, paths)\n    print([item[\"args\"] for item in results])\n\nasyncio.run(main())\n</code></pre> <p>This prints: <pre><code>Making async requests: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [00:00&lt;00:00,  9.98it/s]\n[{'i': '0'}, {'i': '1'}, {'i': '2'}, {'i': '3'}, {'i': '4'}]\n</code></pre></p> <p>Similarly, we can do a bunch of POST requests. This time we will use a single path but multiple payloads:</p> <pre><code>import asyncio\nfrom unparallel import up\n\nasync def main():\n    url = \"https://httpbin.org\"\n    path = \"/post\"\n    payloads = [{\"obj_id\": i} for i in range(5)]\n    results = await up(url, path, method=\"post\", payloads=payloads)\n    print([item[\"data\"] for item in results])\n\nasyncio.run(main())\n</code></pre> <p>This prints: <pre><code>Making async requests: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [00:00&lt;00:00,  9.98it/s]\n['{\"obj_id\": 0}', '{\"obj_id\": 1}', '{\"obj_id\": 2}', '{\"obj_id\": 3}', '{\"obj_id\": 4}']\n</code></pre></p>"},{"location":"contributing/","title":"How to contribute","text":""},{"location":"contributing/#dependencies","title":"Dependencies","text":"<p>We use <code>poetry</code> to manage the dependencies. If you dont have <code>poetry</code>, you should install with <code>make poetry-download</code>.</p> <p>To install dependencies and prepare <code>pre-commit</code> hooks you would need to run <code>install</code> command:</p> <pre><code>make install\nmake pre-commit-install\n</code></pre> <p>To activate your <code>virtualenv</code> run <code>poetry shell</code>.</p>"},{"location":"contributing/#codestyle","title":"Codestyle","text":"<p>After installation you may execute code formatting.</p> <pre><code>make codestyle\n</code></pre>"},{"location":"contributing/#checks","title":"Checks","text":"<p>Many checks are configured for this project. Command <code>make check-codestyle</code> will check black and isort. The <code>make check-typing</code> command will run mypy to check for typing issues. </p> <p>Comand <code>make lint</code> applies both checks above.</p> <p>The <code>make check-safety</code> command will look at the security of your code. </p>"},{"location":"contributing/#before-submitting","title":"Before submitting","text":"<p>Before submitting your code please do the following steps:</p> <ol> <li>Add any changes you want</li> <li>Add tests for the new changes</li> <li>Edit documentation if you have changed something significant</li> <li>Run <code>make codestyle</code> to format your changes.</li> <li>Run <code>make lint</code> to ensure that types, security and docstrings are okay.</li> </ol>"},{"location":"contributing/#other-help","title":"Other help","text":"<p>You can contribute by spreading a word about this library. It would also be a huge contribution to write a short article on how you are using this project. You can also share your best practices with us.</p>"},{"location":"contributing/#makefile-reference","title":"Makefile reference","text":"<p><code>Makefile</code> contains a lot of functions for faster development.</p> 1. Download and remove Poetry <p>  To download and install Poetry run:  <pre><code>make poetry-download\n</code></pre>  To uninstall  <pre><code>make poetry-remove\n</code></pre> </p> 2. Install all dependencies and pre-commit hooks <p>  Install requirements:  <pre><code>make install\n</code></pre>  Pre-commit hooks coulb be installed after `git init` via  <pre><code>make pre-commit-install\n</code></pre> </p> 3. Codestyle <p>  Automatic formatting uses `pyupgrade`, `isort` and `black`.  <pre><code>make codestyle\n\n# or use synonym\nmake formatting\n</code></pre>  Codestyle checks only, without rewriting files:  <pre><code>make check-codestyle\n</code></pre>  &gt; Note: `check-codestyle` uses `isort` and `black` library   4. Code security <p> <pre><code>make check-safety\n</code></pre>  This command launches `Poetry` integrity checks as well as identifies security issues with `Safety` and `Bandit`.  <pre><code>make check-safety\n</code></pre> </p> </p> 5. Type checks <p>  Run `mypy` static type checker  <pre><code>make check-typing\n</code></pre> </p> 6. Tests with coverage badges <p>  Run `pytest`  <pre><code>make test\n</code></pre> </p> 7. All linters <p>  Of course there is a command to run all linters in one:  <pre><code>make lint\n</code></pre>  the same as:  <pre><code>make check-codestyle &amp;&amp; make check-typing\n</code></pre> </p> 8. Docker <p> <pre><code>make docker-build\n</code></pre>  which is equivalent to:  <pre><code>make docker-build VERSION=latest\n</code></pre>  Remove docker image with  <pre><code>make docker-remove\n</code></pre>  More information [about docker](https://github.com/RafaelWO/unparallel/tree/main/docker).  </p> 9. Cleanup <p> Delete pycache files  <pre><code>make pycache-remove\n</code></pre>  Remove package build  <pre><code>make build-remove\n</code></pre>  Delete .DS_STORE files  <pre><code>make dsstore-remove\n</code></pre>  Remove .mypycache  <pre><code>make mypycache-remove\n</code></pre>  Or to remove all above run:  <pre><code>make cleanup\n</code></pre> </p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#unparallel","title":"<code>unparallel</code>","text":"<p>Create async web requests in no time.</p>"},{"location":"reference/#unparallel.RequestError","title":"<code>RequestError</code>  <code>dataclass</code>","text":"<p>A dataclass wrapping an exception that was raised during a web request.</p> <p>Besides the exception itself, this contains the path, method, and (optional) payload of the failed request.</p> Source code in <code>unparallel/unparallel.py</code> <pre><code>@dataclass\nclass RequestError:\n    \"\"\"A dataclass wrapping an exception that was raised during a web request.\n\n    Besides the exception itself, this contains the path, method, and (optional) payload\n    of the failed request.\n    \"\"\"\n\n    path: str\n    method: str\n    payload: Optional[Any]\n    exception: Exception\n</code></pre>"},{"location":"reference/#unparallel.up","title":"<code>up(base_url, paths, method='get', headers=None, payloads=None, flatten_result=False, connection_limit=100, max_retries_on_timeout=3, progress=True)</code>  <code>async</code>","text":"<p>Creates async web requests to a URL at the specified path(s) via <code>asyncio</code> and <code>httpx</code>.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the target API/service.</p> required <code>paths</code> <code>Union[str, List[str]]</code> <p>One path or a list of paths, e.g. /foobar/. If one path but multiple payloads are supplied, that path is used for all requests.</p> required <code>method</code> <code>str</code> <p>HTTP method to use, e.g. get, post, etc. Defaults to \"get\".</p> <code>'get'</code> <code>headers</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary of headers to use. Defaults to None.</p> <code>None</code> <code>payloads</code> <code>Optional[Any]</code> <p>A list of JSON payloads (dictionaries) e.g. for HTTP post requests. Used together with paths. Defaults to None.</p> <code>None</code> <code>flatten_result</code> <code>bool</code> <p>If True and the response per request is a list, flatten that list of lists. This is useful when using paging. Defaults to False.</p> <code>False</code> <code>connection_limit</code> <code>int</code> <p>The total number of simultaneous TCP connections. Defaults to 100.</p> <code>100</code> <code>max_retries_on_timeout</code> <code>int</code> <p>The maximum number retries if the requests fails due to a timeout (<code>httpx.TimeoutException</code>). Defauls to 3.</p> <code>3</code> <code>progress</code> <code>bool</code> <p>If set to True, progress bar is shown. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the HTTP method is not valid.</p> <code>ValueError</code> <p>If the number of paths provided does not match the number of payloads (except if there is only one path).</p> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]:  A list of the response data per request in the same order as the</p> <code>List[Any]</code> <p>input (paths/payloads).</p> Source code in <code>unparallel/unparallel.py</code> <pre><code>async def up(\n    base_url: str,\n    paths: Union[str, List[str]],\n    method: str = \"get\",\n    headers: Optional[Dict[str, Any]] = None,\n    payloads: Optional[Any] = None,\n    flatten_result: bool = False,\n    connection_limit: int = 100,\n    max_retries_on_timeout: int = 3,\n    progress: bool = True,\n) -&gt; List[Any]:\n    \"\"\"Creates async web requests to a URL at the specified path(s) via ``asyncio``\n    and ``httpx``.\n\n    Args:\n        base_url (str):  The base URL of the target API/service.\n        paths (Union[str, List[str]]): One path or a list of paths, e.g. /foobar/.\n            If one path but multiple payloads are supplied, that path is used for all\n            requests.\n        method (str): HTTP method to use, e.g. get, post, etc.\n            Defaults to \"get\".\n        headers (Optional[Dict[str, Any]], optional): A dictionary of headers to use.\n            Defaults to None.\n        payloads (Optional[Any], optional): A list of JSON payloads (dictionaries) e.g.\n            for HTTP post requests. Used together with paths. Defaults to None.\n        flatten_result (bool): If True and the response per request is a list,\n            flatten that list of lists. This is useful when using paging.\n            Defaults to False.\n        connection_limit (int): The total number of simultaneous TCP\n            connections. Defaults to 100.\n        max_retries_on_timeout (int): The maximum number retries if the requests fails\n            due to a timeout (``httpx.TimeoutException``). Defauls to 3.\n        progress (bool): If set to True, progress bar is shown.\n            Defaults to True.\n\n    Raises:\n        ValueError: If the HTTP method is not valid.\n        ValueError: If the number of paths provided does not match the number of\n            payloads (except if there is only one path).\n\n\n    Returns:\n        List[Any]:  A list of the response data per request in the same order as the\n        input (paths/payloads).\n    \"\"\"\n    # Check if method it valid\n    if method not in VALID_HTTP_METHODS:\n        raise ValueError(\n            f\"The method '{method}' is not a supported HTTP method. \"\n            f\"Supported methods: {VALID_HTTP_METHODS}\"\n        )\n\n    # Check if payloads align with paths\n    if payloads:\n        if isinstance(paths, str):\n            paths = [paths]\n        if len(paths) == 1 and len(payloads) &gt; 1:\n            logging.info(f\"Using path '{paths[0]}' for all {len(payloads)} payloads\")\n            paths = paths * len(payloads)\n        if len(paths) != len(payloads):\n            raise ValueError(\n                f\"The number of paths does not match the number of payloads: \"\n                f\"{len(paths)} != {len(payloads)}\"\n            )\n\n    logging.debug(\n        f\"Issuing {len(paths)} {method.upper()} request(s) to base URL '{base_url}' \"\n        f\"with {connection_limit} max connections...\"\n    )\n    return await request_urls(\n        base_url=base_url,\n        paths=paths,\n        method=method,\n        headers=headers,\n        payloads=payloads,\n        flatten_result=flatten_result,\n        connection_limit=connection_limit,\n        max_retries_on_timeout=max_retries_on_timeout,\n        progress=progress,\n    )\n</code></pre>"},{"location":"reference/#unparallel.unparallel","title":"<code>unparallel.unparallel</code>","text":""},{"location":"reference/#unparallel.unparallel.sort_by_idx","title":"<code>sort_by_idx(results)</code>","text":"<p>Sorts a list of tuples (index, value) by the index and return just the values.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Tuple[int, Any]]</code> <p>A list of tuples (index, value) to be sorted.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: The values as a list.</p> Source code in <code>unparallel/unparallel.py</code> <pre><code>def sort_by_idx(results: List[Tuple[int, Any]]) -&gt; List[Any]:\n    \"\"\"Sorts a list of tuples (index, value) by the index and return just the values.\n\n    Args:\n        results (List[Tuple[int, Any]]): A list of tuples (index, value) to be sorted.\n\n    Returns:\n        List[Any]: The values as a list.\n    \"\"\"\n    return [item[1] for item in sorted(results, key=lambda x: x[0])]\n</code></pre>"},{"location":"reference/#unparallel.unparallel.single_request","title":"<code>single_request(idx, client, path, method, json=None, max_retries_on_timeout=3)</code>  <code>async</code>","text":"<p>Do a single web request for the given path, HTTP method, and playload.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the task (required for sorting afterwards)</p> required <code>client</code> <code>AsyncClient</code> <p>The httpx client</p> required <code>path</code> <code>str</code> <p>The path after the base URI</p> required <code>method</code> <code>str</code> <p>The HTTP method</p> required <code>json</code> <code>Optional[Any]</code> <p>The JSON payload. Defaults to None.</p> <code>None</code> <code>max_retries_on_timeout</code> <code>int</code> <p>The maximum number retries if the requests fails due to a timeout (<code>httpx.TimeoutException</code>). Defauls to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>Tuple[int, Any]</code> <p>Tuple[int, Any]: A tuple of the index and the JSON response.</p> Source code in <code>unparallel/unparallel.py</code> <pre><code>async def single_request(\n    idx: int,\n    client: AsyncClient,\n    path: str,\n    method: str,\n    json: Optional[Any] = None,\n    max_retries_on_timeout: int = 3,\n) -&gt; Tuple[int, Any]:\n    \"\"\"Do a single web request for the given path, HTTP method, and playload.\n\n    Args:\n        idx (int): The index of the task (required for sorting afterwards)\n        client (AsyncClient): The httpx client\n        path (str): The path after the base URI\n        method (str): The HTTP method\n        json (Optional[Any], optional): The JSON payload. Defaults to None.\n        max_retries_on_timeout (int): The maximum number retries if the requests fails\n            due to a timeout (``httpx.TimeoutException``). Defauls to 3.\n\n    Returns:\n        Tuple[int, Any]: A tuple of the index and the JSON response.\n    \"\"\"\n    trial = 0\n    exception: Optional[Exception] = None\n    method = method.lower()\n    for trial in range(1, max_retries_on_timeout + 1):\n        try:\n            kwargs = {}\n            if method in [\"post\", \"put\", \"patch\"]:\n                kwargs[\"json\"] = json\n            response = await getattr(client, method.lower())(path, **kwargs)\n            response.raise_for_status()\n            json_data = response.json()\n            return idx, json_data\n        except TimeoutException as timeout_ex:\n            exception = timeout_ex\n            await asyncio.sleep(1)\n        except Exception as ex:  # pylint: disable=broad-except\n            exception = ex\n            break\n\n    # this assert is here to make mypy happy\n    assert exception is not None\n    logger.warning(\n        f\"{exception.__class__.__name__} was raised after {trial} tries: {exception}\"\n    )\n    return (\n        idx,\n        RequestError(\n            path=path,\n            method=method,\n            payload=json,\n            exception=exception,\n        ),\n    )\n</code></pre>"},{"location":"reference/#unparallel.unparallel.request_urls","title":"<code>request_urls(base_url, paths, method='get', headers=None, payloads=None, flatten_result=False, connection_limit=100, max_retries_on_timeout=3, progress=True)</code>  <code>async</code>","text":"<p>Asynchronously issues requests to a URL at the specified path(s) via <code>asyncio</code> and <code>httpx</code>.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the service, e.g. http://localhost:8000.</p> required <code>paths</code> <code>Union[str, List[str]]</code> <p>One path or a list of paths, e.g. /foobar/. If one path but multiple payloads are supplied, that path is used for all requests.</p> required <code>method</code> <code>str</code> <p>HTTP method to use, e.g. get, post, etc.</p> <code>'get'</code> <code>headers</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary of headers to use.</p> <code>None</code> <code>payloads</code> <code>Optional[Any]</code> <p>A list of JSON payloads (dictionaries) for e.g. HTTP post requests. Used together with paths.</p> <code>None</code> <code>flatten_result</code> <code>bool</code> <p>If True and the response per request is a list, flatten that list of lists. This is useful when using paging.</p> <code>False</code> <code>connection_limit</code> <code>int</code> <p>The total number of simultaneous TCP connections</p> <code>100</code> <code>max_retries_on_timeout</code> <code>int</code> <p>The maximum number retries if the requests fails due to a timeout (<code>httpx.TimeoutException</code>). Defauls to 3.</p> <code>3</code> <code>progress</code> <code>bool</code> <p>If set to True, progress bar is shown</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list of the response data per request in the same order as the input</p> <code>List[Any]</code> <p>(paths/payloads).</p> Source code in <code>unparallel/unparallel.py</code> <pre><code>async def request_urls(\n    base_url: str,\n    paths: Union[str, List[str]],\n    method: str = \"get\",\n    headers: Optional[Dict[str, Any]] = None,\n    payloads: Optional[Any] = None,\n    flatten_result: bool = False,\n    connection_limit: int = 100,\n    max_retries_on_timeout: int = 3,\n    progress: bool = True,\n) -&gt; List[Any]:\n    \"\"\"\n    Asynchronously issues requests to a URL at the specified path(s)\n    via ``asyncio`` and ``httpx``.\n\n    Args:\n        base_url: The base URL of the service, e.g. http://localhost:8000.\n        paths: One path or a list of paths, e.g. /foobar/. If one path but multiple\n            payloads are supplied, that path is used for all requests.\n        method: HTTP method to use, e.g. get, post, etc.\n        headers: A dictionary of headers to use.\n        payloads: A list of JSON payloads (dictionaries) for e.g. HTTP post requests.\n            Used together with paths.\n        flatten_result: If True and the response per request is a list, flatten that\n            list of lists. This is useful when using paging.\n        connection_limit: The total number of simultaneous TCP connections\n        max_retries_on_timeout (int): The maximum number retries if the requests fails\n            due to a timeout (``httpx.TimeoutException``). Defauls to 3.\n        progress: If set to True, progress bar is shown\n\n    Returns:\n        A list of the response data per request in the same order as the input\n        (paths/payloads).\n    \"\"\"\n    tasks = []\n    results = []\n\n    limits = Limits(max_connections=connection_limit)\n    async with AsyncClient(base_url=base_url, headers=headers, limits=limits) as client:\n        for i, path in enumerate(paths):\n            task = asyncio.create_task(\n                single_request(\n                    idx=i,\n                    path=path,\n                    client=client,\n                    method=method,\n                    json=payloads[i] if payloads else None,\n                )\n            )\n            tasks.append(task)\n\n        for task in tqdm_async.as_completed(\n            tasks, desc=\"Making async requests\", disable=not progress\n        ):\n            res = await task\n            results.append(res)\n\n    results = sort_by_idx(results)\n    if flatten_result:\n        return [item for sublist in results for item in sublist]\n    return results\n</code></pre>"},{"location":"releases/","title":"Releases","text":"<p>You can see the list of available releases on the GitHub Releases page.</p> <p>We follow Semantic Versions specification.</p> <p>We use <code>Release Drafter</code>. As pull requests are merged, a draft release is kept up-to-date listing the changes, ready to publish when you\u2019re ready. With the categories option, you can categorize pull requests in release notes using labels.</p>"},{"location":"releases/#list-of-labels-and-corresponding-titles","title":"List of labels and corresponding titles","text":"Label Title in Releases <code>enhancement</code>, <code>feature</code> \ud83d\ude80 Features <code>bug</code>, <code>refactoring</code>, <code>bugfix</code>, <code>fix</code> \ud83d\udd27 Fixes &amp; Refactoring <code>build</code>, <code>ci</code>, <code>testing</code> \ud83d\udce6 Build System &amp; CI/CD <code>breaking</code> \ud83d\udca5 Breaking Changes <code>documentation</code> \ud83d\udcdd Documentation <code>dependencies</code> \u2b06\ufe0f Dependencies updates <p>You can update it in <code>release-drafter.yml</code>.</p> <p>GitHub creates the <code>bug</code>, <code>enhancement</code>, and <code>documentation</code> labels for you. Dependabot creates the <code>dependencies</code> label. Create the remaining labels on the Issues tab of your GitHub repository, when you need them.</p>"}]}